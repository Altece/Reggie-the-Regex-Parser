{"name":"Reggie the Regex Parser","tagline":"A regex parser with the ability to match strings to a regular expression.","body":"Reggie the Regex Parser\r\n=======================\r\n\r\nReggie the Regex Parser (RRP) is a regualr expression parser that will have the ability to identify strings that match the regular expression.\r\n\r\nPurpose\r\n-------\r\n\r\nTo learn about and understand regualr expressions and finite automata.\r\n\r\nTo write awesome things in the C language.\r\n\r\nTo become a badass and super-being among mortals.\r\n\r\nTo create the foundations for a regex parser for possible future use in attempts at creating compilers.\r\n\r\nDesign\r\n------\r\n\r\nRegualr expressions are written forms of a non-deterministic finite automata (NFA), which represents a machine that matches strings of characters for patterns encoded within the machine.\r\n\r\nAn NFA is a directed graph with one initial node state (known as \"q0\") and any number of other states. Any number of states within the NFA can be an accepting state that would signify the acceptance of a string when the string encounters its end. Transitions between states are invoked by encountering specified characters. [Learn more about NFAs from Wikipedia](http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton).\r\n\r\nThis regex parser will take a regualr expression string and create an NFA modeled by that string.\r\n\r\nA user can then take the resulting NFA and pass in a string to see if it passes the NFA.\r\n\r\nNFAs for Use with Parsing\r\n-------------------------\r\n\r\nA strict NFA would not be useful for parsing purposes. If you wanted to tokenize using an NFA, you would need to know how long the string that is accepted by the NFA is, and you would need to be able to deal with anything following the final accept terminal state.\r\n\r\nA parsing evaluator needs to be implemented to allow for the length of any accepting substring in an input string, so long as the substring and the input string start together.\r\n\r\nNFA Copying\r\n-----------\r\n\r\nThe recursive structure of an NFA makes cloning and copying less than arbitrary. A template representing a blueprint for the NFA is created, and then an NFA structure is built from the generated template.\r\n\r\nThe template is a map of state pointers to state representations, and from transition pointers to transition representations.\r\n\r\nPublic Interface\r\n----------------\r\n\r\nThe `reggie.h` file reveals the public interface for the regex parser. This file includes function definitions that facilitate the creation, destruction, use for matching, use for parsing, and manipulation of regualr expressions backed by NFAs.\r\n\r\nPossible Future Exploations\r\n---------------------------\r\n\r\nThe use of a modified Non-Deterministic Push-Down Automata (PDA) may be useful for implementing a regular-expression parsing machine that could also be used outside the regex parsing to become a general-purpose parser.\r\n\r\nSource Highlights\r\n-----------------\r\n\r\n`list.h` is a mean C Linked-List Library featuring a `FOREACH` macro looping construct and more.\r\n\r\n`map.h` is a map or dictionary implementation based on the `list.h` library allowing for primative key-value storying of any pointer data values.\r\n\r\n`nfa.h` holds the structure of the Non-Deterministic Finite Automata and it's parts.\r\n\r\nCompilation\r\n-----------\r\n\r\nTo compile and run tests, run\r\n\r\n\tmake test\r\n\r\nTo clean the build files, run\r\n\r\n\tmake clean\r\n\r\nTo clean the build files and binaries, run\r\n\r\n\tmake real-clean\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}